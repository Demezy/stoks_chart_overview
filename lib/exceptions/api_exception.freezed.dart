// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'api_exception.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$ApiException {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() tokenLimitExceeded,
    required TResult Function(String sym) notFound,
    required TResult Function() unrecognizedServerResponse,
    required TResult Function() apiUnavailable,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? tokenLimitExceeded,
    TResult? Function(String sym)? notFound,
    TResult? Function()? unrecognizedServerResponse,
    TResult? Function()? apiUnavailable,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? tokenLimitExceeded,
    TResult Function(String sym)? notFound,
    TResult Function()? unrecognizedServerResponse,
    TResult Function()? apiUnavailable,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_TokenLimitExceeded value) tokenLimitExceeded,
    required TResult Function(_NotFound value) notFound,
    required TResult Function(_UnrecognizedServerResponse value)
        unrecognizedServerResponse,
    required TResult Function(_ApiUnavailable value) apiUnavailable,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_TokenLimitExceeded value)? tokenLimitExceeded,
    TResult? Function(_NotFound value)? notFound,
    TResult? Function(_UnrecognizedServerResponse value)?
        unrecognizedServerResponse,
    TResult? Function(_ApiUnavailable value)? apiUnavailable,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_TokenLimitExceeded value)? tokenLimitExceeded,
    TResult Function(_NotFound value)? notFound,
    TResult Function(_UnrecognizedServerResponse value)?
        unrecognizedServerResponse,
    TResult Function(_ApiUnavailable value)? apiUnavailable,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ApiExceptionCopyWith<$Res> {
  factory $ApiExceptionCopyWith(
          ApiException value, $Res Function(ApiException) then) =
      _$ApiExceptionCopyWithImpl<$Res, ApiException>;
}

/// @nodoc
class _$ApiExceptionCopyWithImpl<$Res, $Val extends ApiException>
    implements $ApiExceptionCopyWith<$Res> {
  _$ApiExceptionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_TokenLimitExceededCopyWith<$Res> {
  factory _$$_TokenLimitExceededCopyWith(_$_TokenLimitExceeded value,
          $Res Function(_$_TokenLimitExceeded) then) =
      __$$_TokenLimitExceededCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_TokenLimitExceededCopyWithImpl<$Res>
    extends _$ApiExceptionCopyWithImpl<$Res, _$_TokenLimitExceeded>
    implements _$$_TokenLimitExceededCopyWith<$Res> {
  __$$_TokenLimitExceededCopyWithImpl(
      _$_TokenLimitExceeded _value, $Res Function(_$_TokenLimitExceeded) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_TokenLimitExceeded
    with DiagnosticableTreeMixin
    implements _TokenLimitExceeded {
  const _$_TokenLimitExceeded();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ApiException.tokenLimitExceeded()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
        .add(DiagnosticsProperty('type', 'ApiException.tokenLimitExceeded'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_TokenLimitExceeded);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() tokenLimitExceeded,
    required TResult Function(String sym) notFound,
    required TResult Function() unrecognizedServerResponse,
    required TResult Function() apiUnavailable,
  }) {
    return tokenLimitExceeded();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? tokenLimitExceeded,
    TResult? Function(String sym)? notFound,
    TResult? Function()? unrecognizedServerResponse,
    TResult? Function()? apiUnavailable,
  }) {
    return tokenLimitExceeded?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? tokenLimitExceeded,
    TResult Function(String sym)? notFound,
    TResult Function()? unrecognizedServerResponse,
    TResult Function()? apiUnavailable,
    required TResult orElse(),
  }) {
    if (tokenLimitExceeded != null) {
      return tokenLimitExceeded();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_TokenLimitExceeded value) tokenLimitExceeded,
    required TResult Function(_NotFound value) notFound,
    required TResult Function(_UnrecognizedServerResponse value)
        unrecognizedServerResponse,
    required TResult Function(_ApiUnavailable value) apiUnavailable,
  }) {
    return tokenLimitExceeded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_TokenLimitExceeded value)? tokenLimitExceeded,
    TResult? Function(_NotFound value)? notFound,
    TResult? Function(_UnrecognizedServerResponse value)?
        unrecognizedServerResponse,
    TResult? Function(_ApiUnavailable value)? apiUnavailable,
  }) {
    return tokenLimitExceeded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_TokenLimitExceeded value)? tokenLimitExceeded,
    TResult Function(_NotFound value)? notFound,
    TResult Function(_UnrecognizedServerResponse value)?
        unrecognizedServerResponse,
    TResult Function(_ApiUnavailable value)? apiUnavailable,
    required TResult orElse(),
  }) {
    if (tokenLimitExceeded != null) {
      return tokenLimitExceeded(this);
    }
    return orElse();
  }
}

abstract class _TokenLimitExceeded implements ApiException {
  const factory _TokenLimitExceeded() = _$_TokenLimitExceeded;
}

/// @nodoc
abstract class _$$_NotFoundCopyWith<$Res> {
  factory _$$_NotFoundCopyWith(
          _$_NotFound value, $Res Function(_$_NotFound) then) =
      __$$_NotFoundCopyWithImpl<$Res>;
  @useResult
  $Res call({String sym});
}

/// @nodoc
class __$$_NotFoundCopyWithImpl<$Res>
    extends _$ApiExceptionCopyWithImpl<$Res, _$_NotFound>
    implements _$$_NotFoundCopyWith<$Res> {
  __$$_NotFoundCopyWithImpl(
      _$_NotFound _value, $Res Function(_$_NotFound) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? sym = null,
  }) {
    return _then(_$_NotFound(
      null == sym
          ? _value.sym
          : sym // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_NotFound with DiagnosticableTreeMixin implements _NotFound {
  const _$_NotFound(this.sym);

  @override
  final String sym;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ApiException.notFound(sym: $sym)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ApiException.notFound'))
      ..add(DiagnosticsProperty('sym', sym));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_NotFound &&
            (identical(other.sym, sym) || other.sym == sym));
  }

  @override
  int get hashCode => Object.hash(runtimeType, sym);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_NotFoundCopyWith<_$_NotFound> get copyWith =>
      __$$_NotFoundCopyWithImpl<_$_NotFound>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() tokenLimitExceeded,
    required TResult Function(String sym) notFound,
    required TResult Function() unrecognizedServerResponse,
    required TResult Function() apiUnavailable,
  }) {
    return notFound(sym);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? tokenLimitExceeded,
    TResult? Function(String sym)? notFound,
    TResult? Function()? unrecognizedServerResponse,
    TResult? Function()? apiUnavailable,
  }) {
    return notFound?.call(sym);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? tokenLimitExceeded,
    TResult Function(String sym)? notFound,
    TResult Function()? unrecognizedServerResponse,
    TResult Function()? apiUnavailable,
    required TResult orElse(),
  }) {
    if (notFound != null) {
      return notFound(sym);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_TokenLimitExceeded value) tokenLimitExceeded,
    required TResult Function(_NotFound value) notFound,
    required TResult Function(_UnrecognizedServerResponse value)
        unrecognizedServerResponse,
    required TResult Function(_ApiUnavailable value) apiUnavailable,
  }) {
    return notFound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_TokenLimitExceeded value)? tokenLimitExceeded,
    TResult? Function(_NotFound value)? notFound,
    TResult? Function(_UnrecognizedServerResponse value)?
        unrecognizedServerResponse,
    TResult? Function(_ApiUnavailable value)? apiUnavailable,
  }) {
    return notFound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_TokenLimitExceeded value)? tokenLimitExceeded,
    TResult Function(_NotFound value)? notFound,
    TResult Function(_UnrecognizedServerResponse value)?
        unrecognizedServerResponse,
    TResult Function(_ApiUnavailable value)? apiUnavailable,
    required TResult orElse(),
  }) {
    if (notFound != null) {
      return notFound(this);
    }
    return orElse();
  }
}

abstract class _NotFound implements ApiException {
  const factory _NotFound(final String sym) = _$_NotFound;

  String get sym;
  @JsonKey(ignore: true)
  _$$_NotFoundCopyWith<_$_NotFound> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_UnrecognizedServerResponseCopyWith<$Res> {
  factory _$$_UnrecognizedServerResponseCopyWith(
          _$_UnrecognizedServerResponse value,
          $Res Function(_$_UnrecognizedServerResponse) then) =
      __$$_UnrecognizedServerResponseCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_UnrecognizedServerResponseCopyWithImpl<$Res>
    extends _$ApiExceptionCopyWithImpl<$Res, _$_UnrecognizedServerResponse>
    implements _$$_UnrecognizedServerResponseCopyWith<$Res> {
  __$$_UnrecognizedServerResponseCopyWithImpl(
      _$_UnrecognizedServerResponse _value,
      $Res Function(_$_UnrecognizedServerResponse) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_UnrecognizedServerResponse
    with DiagnosticableTreeMixin
    implements _UnrecognizedServerResponse {
  const _$_UnrecognizedServerResponse();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ApiException.unrecognizedServerResponse()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(
        DiagnosticsProperty('type', 'ApiException.unrecognizedServerResponse'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UnrecognizedServerResponse);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() tokenLimitExceeded,
    required TResult Function(String sym) notFound,
    required TResult Function() unrecognizedServerResponse,
    required TResult Function() apiUnavailable,
  }) {
    return unrecognizedServerResponse();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? tokenLimitExceeded,
    TResult? Function(String sym)? notFound,
    TResult? Function()? unrecognizedServerResponse,
    TResult? Function()? apiUnavailable,
  }) {
    return unrecognizedServerResponse?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? tokenLimitExceeded,
    TResult Function(String sym)? notFound,
    TResult Function()? unrecognizedServerResponse,
    TResult Function()? apiUnavailable,
    required TResult orElse(),
  }) {
    if (unrecognizedServerResponse != null) {
      return unrecognizedServerResponse();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_TokenLimitExceeded value) tokenLimitExceeded,
    required TResult Function(_NotFound value) notFound,
    required TResult Function(_UnrecognizedServerResponse value)
        unrecognizedServerResponse,
    required TResult Function(_ApiUnavailable value) apiUnavailable,
  }) {
    return unrecognizedServerResponse(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_TokenLimitExceeded value)? tokenLimitExceeded,
    TResult? Function(_NotFound value)? notFound,
    TResult? Function(_UnrecognizedServerResponse value)?
        unrecognizedServerResponse,
    TResult? Function(_ApiUnavailable value)? apiUnavailable,
  }) {
    return unrecognizedServerResponse?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_TokenLimitExceeded value)? tokenLimitExceeded,
    TResult Function(_NotFound value)? notFound,
    TResult Function(_UnrecognizedServerResponse value)?
        unrecognizedServerResponse,
    TResult Function(_ApiUnavailable value)? apiUnavailable,
    required TResult orElse(),
  }) {
    if (unrecognizedServerResponse != null) {
      return unrecognizedServerResponse(this);
    }
    return orElse();
  }
}

abstract class _UnrecognizedServerResponse implements ApiException {
  const factory _UnrecognizedServerResponse() = _$_UnrecognizedServerResponse;
}

/// @nodoc
abstract class _$$_ApiUnavailableCopyWith<$Res> {
  factory _$$_ApiUnavailableCopyWith(
          _$_ApiUnavailable value, $Res Function(_$_ApiUnavailable) then) =
      __$$_ApiUnavailableCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_ApiUnavailableCopyWithImpl<$Res>
    extends _$ApiExceptionCopyWithImpl<$Res, _$_ApiUnavailable>
    implements _$$_ApiUnavailableCopyWith<$Res> {
  __$$_ApiUnavailableCopyWithImpl(
      _$_ApiUnavailable _value, $Res Function(_$_ApiUnavailable) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_ApiUnavailable
    with DiagnosticableTreeMixin
    implements _ApiUnavailable {
  const _$_ApiUnavailable();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ApiException.apiUnavailable()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'ApiException.apiUnavailable'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_ApiUnavailable);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() tokenLimitExceeded,
    required TResult Function(String sym) notFound,
    required TResult Function() unrecognizedServerResponse,
    required TResult Function() apiUnavailable,
  }) {
    return apiUnavailable();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? tokenLimitExceeded,
    TResult? Function(String sym)? notFound,
    TResult? Function()? unrecognizedServerResponse,
    TResult? Function()? apiUnavailable,
  }) {
    return apiUnavailable?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? tokenLimitExceeded,
    TResult Function(String sym)? notFound,
    TResult Function()? unrecognizedServerResponse,
    TResult Function()? apiUnavailable,
    required TResult orElse(),
  }) {
    if (apiUnavailable != null) {
      return apiUnavailable();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_TokenLimitExceeded value) tokenLimitExceeded,
    required TResult Function(_NotFound value) notFound,
    required TResult Function(_UnrecognizedServerResponse value)
        unrecognizedServerResponse,
    required TResult Function(_ApiUnavailable value) apiUnavailable,
  }) {
    return apiUnavailable(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_TokenLimitExceeded value)? tokenLimitExceeded,
    TResult? Function(_NotFound value)? notFound,
    TResult? Function(_UnrecognizedServerResponse value)?
        unrecognizedServerResponse,
    TResult? Function(_ApiUnavailable value)? apiUnavailable,
  }) {
    return apiUnavailable?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_TokenLimitExceeded value)? tokenLimitExceeded,
    TResult Function(_NotFound value)? notFound,
    TResult Function(_UnrecognizedServerResponse value)?
        unrecognizedServerResponse,
    TResult Function(_ApiUnavailable value)? apiUnavailable,
    required TResult orElse(),
  }) {
    if (apiUnavailable != null) {
      return apiUnavailable(this);
    }
    return orElse();
  }
}

abstract class _ApiUnavailable implements ApiException {
  const factory _ApiUnavailable() = _$_ApiUnavailable;
}
