// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'api_exception.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$ApiException {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() apiRateLimitExceeded,
    required TResult Function() unrecognizedServerResponse,
    required TResult Function() apiUnavailable,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? apiRateLimitExceeded,
    TResult? Function()? unrecognizedServerResponse,
    TResult? Function()? apiUnavailable,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? apiRateLimitExceeded,
    TResult Function()? unrecognizedServerResponse,
    TResult Function()? apiUnavailable,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ApiRateLimitExceeded value) apiRateLimitExceeded,
    required TResult Function(_UnrecognizedServerResponse value)
        unrecognizedServerResponse,
    required TResult Function(_ApiUnavailable value) apiUnavailable,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ApiRateLimitExceeded value)? apiRateLimitExceeded,
    TResult? Function(_UnrecognizedServerResponse value)?
        unrecognizedServerResponse,
    TResult? Function(_ApiUnavailable value)? apiUnavailable,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ApiRateLimitExceeded value)? apiRateLimitExceeded,
    TResult Function(_UnrecognizedServerResponse value)?
        unrecognizedServerResponse,
    TResult Function(_ApiUnavailable value)? apiUnavailable,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ApiExceptionCopyWith<$Res> {
  factory $ApiExceptionCopyWith(
          ApiException value, $Res Function(ApiException) then) =
      _$ApiExceptionCopyWithImpl<$Res, ApiException>;
}

/// @nodoc
class _$ApiExceptionCopyWithImpl<$Res, $Val extends ApiException>
    implements $ApiExceptionCopyWith<$Res> {
  _$ApiExceptionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_ApiRateLimitExceededCopyWith<$Res> {
  factory _$$_ApiRateLimitExceededCopyWith(_$_ApiRateLimitExceeded value,
          $Res Function(_$_ApiRateLimitExceeded) then) =
      __$$_ApiRateLimitExceededCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_ApiRateLimitExceededCopyWithImpl<$Res>
    extends _$ApiExceptionCopyWithImpl<$Res, _$_ApiRateLimitExceeded>
    implements _$$_ApiRateLimitExceededCopyWith<$Res> {
  __$$_ApiRateLimitExceededCopyWithImpl(_$_ApiRateLimitExceeded _value,
      $Res Function(_$_ApiRateLimitExceeded) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_ApiRateLimitExceeded
    with DiagnosticableTreeMixin
    implements _ApiRateLimitExceeded {
  const _$_ApiRateLimitExceeded();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ApiException.apiRateLimitExceeded()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
        .add(DiagnosticsProperty('type', 'ApiException.apiRateLimitExceeded'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_ApiRateLimitExceeded);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() apiRateLimitExceeded,
    required TResult Function() unrecognizedServerResponse,
    required TResult Function() apiUnavailable,
  }) {
    return apiRateLimitExceeded();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? apiRateLimitExceeded,
    TResult? Function()? unrecognizedServerResponse,
    TResult? Function()? apiUnavailable,
  }) {
    return apiRateLimitExceeded?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? apiRateLimitExceeded,
    TResult Function()? unrecognizedServerResponse,
    TResult Function()? apiUnavailable,
    required TResult orElse(),
  }) {
    if (apiRateLimitExceeded != null) {
      return apiRateLimitExceeded();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ApiRateLimitExceeded value) apiRateLimitExceeded,
    required TResult Function(_UnrecognizedServerResponse value)
        unrecognizedServerResponse,
    required TResult Function(_ApiUnavailable value) apiUnavailable,
  }) {
    return apiRateLimitExceeded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ApiRateLimitExceeded value)? apiRateLimitExceeded,
    TResult? Function(_UnrecognizedServerResponse value)?
        unrecognizedServerResponse,
    TResult? Function(_ApiUnavailable value)? apiUnavailable,
  }) {
    return apiRateLimitExceeded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ApiRateLimitExceeded value)? apiRateLimitExceeded,
    TResult Function(_UnrecognizedServerResponse value)?
        unrecognizedServerResponse,
    TResult Function(_ApiUnavailable value)? apiUnavailable,
    required TResult orElse(),
  }) {
    if (apiRateLimitExceeded != null) {
      return apiRateLimitExceeded(this);
    }
    return orElse();
  }
}

abstract class _ApiRateLimitExceeded implements ApiException {
  const factory _ApiRateLimitExceeded() = _$_ApiRateLimitExceeded;
}

/// @nodoc
abstract class _$$_UnrecognizedServerResponseCopyWith<$Res> {
  factory _$$_UnrecognizedServerResponseCopyWith(
          _$_UnrecognizedServerResponse value,
          $Res Function(_$_UnrecognizedServerResponse) then) =
      __$$_UnrecognizedServerResponseCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_UnrecognizedServerResponseCopyWithImpl<$Res>
    extends _$ApiExceptionCopyWithImpl<$Res, _$_UnrecognizedServerResponse>
    implements _$$_UnrecognizedServerResponseCopyWith<$Res> {
  __$$_UnrecognizedServerResponseCopyWithImpl(
      _$_UnrecognizedServerResponse _value,
      $Res Function(_$_UnrecognizedServerResponse) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_UnrecognizedServerResponse
    with DiagnosticableTreeMixin
    implements _UnrecognizedServerResponse {
  const _$_UnrecognizedServerResponse();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ApiException.unrecognizedServerResponse()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(
        DiagnosticsProperty('type', 'ApiException.unrecognizedServerResponse'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UnrecognizedServerResponse);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() apiRateLimitExceeded,
    required TResult Function() unrecognizedServerResponse,
    required TResult Function() apiUnavailable,
  }) {
    return unrecognizedServerResponse();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? apiRateLimitExceeded,
    TResult? Function()? unrecognizedServerResponse,
    TResult? Function()? apiUnavailable,
  }) {
    return unrecognizedServerResponse?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? apiRateLimitExceeded,
    TResult Function()? unrecognizedServerResponse,
    TResult Function()? apiUnavailable,
    required TResult orElse(),
  }) {
    if (unrecognizedServerResponse != null) {
      return unrecognizedServerResponse();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ApiRateLimitExceeded value) apiRateLimitExceeded,
    required TResult Function(_UnrecognizedServerResponse value)
        unrecognizedServerResponse,
    required TResult Function(_ApiUnavailable value) apiUnavailable,
  }) {
    return unrecognizedServerResponse(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ApiRateLimitExceeded value)? apiRateLimitExceeded,
    TResult? Function(_UnrecognizedServerResponse value)?
        unrecognizedServerResponse,
    TResult? Function(_ApiUnavailable value)? apiUnavailable,
  }) {
    return unrecognizedServerResponse?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ApiRateLimitExceeded value)? apiRateLimitExceeded,
    TResult Function(_UnrecognizedServerResponse value)?
        unrecognizedServerResponse,
    TResult Function(_ApiUnavailable value)? apiUnavailable,
    required TResult orElse(),
  }) {
    if (unrecognizedServerResponse != null) {
      return unrecognizedServerResponse(this);
    }
    return orElse();
  }
}

abstract class _UnrecognizedServerResponse implements ApiException {
  const factory _UnrecognizedServerResponse() = _$_UnrecognizedServerResponse;
}

/// @nodoc
abstract class _$$_ApiUnavailableCopyWith<$Res> {
  factory _$$_ApiUnavailableCopyWith(
          _$_ApiUnavailable value, $Res Function(_$_ApiUnavailable) then) =
      __$$_ApiUnavailableCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_ApiUnavailableCopyWithImpl<$Res>
    extends _$ApiExceptionCopyWithImpl<$Res, _$_ApiUnavailable>
    implements _$$_ApiUnavailableCopyWith<$Res> {
  __$$_ApiUnavailableCopyWithImpl(
      _$_ApiUnavailable _value, $Res Function(_$_ApiUnavailable) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_ApiUnavailable
    with DiagnosticableTreeMixin
    implements _ApiUnavailable {
  const _$_ApiUnavailable();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ApiException.apiUnavailable()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'ApiException.apiUnavailable'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_ApiUnavailable);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() apiRateLimitExceeded,
    required TResult Function() unrecognizedServerResponse,
    required TResult Function() apiUnavailable,
  }) {
    return apiUnavailable();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? apiRateLimitExceeded,
    TResult? Function()? unrecognizedServerResponse,
    TResult? Function()? apiUnavailable,
  }) {
    return apiUnavailable?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? apiRateLimitExceeded,
    TResult Function()? unrecognizedServerResponse,
    TResult Function()? apiUnavailable,
    required TResult orElse(),
  }) {
    if (apiUnavailable != null) {
      return apiUnavailable();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ApiRateLimitExceeded value) apiRateLimitExceeded,
    required TResult Function(_UnrecognizedServerResponse value)
        unrecognizedServerResponse,
    required TResult Function(_ApiUnavailable value) apiUnavailable,
  }) {
    return apiUnavailable(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ApiRateLimitExceeded value)? apiRateLimitExceeded,
    TResult? Function(_UnrecognizedServerResponse value)?
        unrecognizedServerResponse,
    TResult? Function(_ApiUnavailable value)? apiUnavailable,
  }) {
    return apiUnavailable?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ApiRateLimitExceeded value)? apiRateLimitExceeded,
    TResult Function(_UnrecognizedServerResponse value)?
        unrecognizedServerResponse,
    TResult Function(_ApiUnavailable value)? apiUnavailable,
    required TResult orElse(),
  }) {
    if (apiUnavailable != null) {
      return apiUnavailable(this);
    }
    return orElse();
  }
}

abstract class _ApiUnavailable implements ApiException {
  const factory _ApiUnavailable() = _$_ApiUnavailable;
}
